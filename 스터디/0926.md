# 스터디 문제 풀이

## 백준 1920번

```python
def search(lst,n):
    lower=0
    upper=len(lst)-1
    mid=(lower+upper)//2
    while upper>=lower:
        if n==lst[mid]:
            return 1
        elif n> lst[mid]:
            lower=mid+1
        else:
            upper=mid-1
        mid=(lower+upper)//2
    return 0



N=int(input())
lst=list(map(int,input().split()))
M=int(input())
arr=list(map(int,input().split()))
lst.sort()
        
for i in arr:
    print(search(lst,i))
```





## 백준 6118번 숨바꼭질

```python
N, M =map(int,input().split())
# 인접리스트 생성.
arr=[[] for _ in range(N+1)]

for _ in range(M):
    a,b=map(int,input().split())
    arr[a].append(b)
    arr[b].append(a)

# 방문표시 체크를 위한 리스트 생성
v=[0]*(N+1)

# 초기값 1을 Q에, 방문표시
Q=[1]
v[1]=1

# 최대 거리를 위한 변수 추가
max=0
# 최대 거리의 좌표를 담을 리스트 생성
ans=[]

# while Q == 모두 다 돌게
while Q:
    w=Q.pop(0)
    for i in arr[w]:
        if v[i] ==0:
            Q.append(i)
            v[i]=v[w]+1
            
            # 거리가 커지면 최대거리를 저장하고 그 좌표를 넣음
            if v[i]>max:
                max=v[i]
                ans=[]
                ans.append(i)
            # 최대 거리와 같은 좌표들을 ans리스트에 넣음
            elif v[i]==max:
                ans.append(i)
                
# 문제에서 요구하는 답안 출력
print(*[min(ans),v[min(ans)]-1,len(ans)])
```



## SWEA 복습 _ 전기버스

```python
T=int(input())
for tc in range(1,T+1):
    K, N, M=map(int,input().split())
    lst=list(map(int,input().split()))
    lst.append(N)
    curr=0
    cnt=0
    while curr!=N:
        new=0
        for i in lst:
            if i <=curr+K:
                new=i
            else:
                break
        if new==0:
            cnt=0
            break
        elif new==N:
            break
        else:
            cnt+=1
            curr=new
            lst=lst[lst.index(new)+1:]
    print(f'#{tc} {cnt}')

```





## SWEA_미로의 거리

```python
# 미로의 거리
def check(x,y):
    if x <0 or x>=N or y<0 or y>=N:
        return 0
    else:
        return 1
def bfs():
    Q=[s]
    v[s[0]][s[1]]=1
    while Q:
        w=Q.pop(0)
        for x,y in [(-1,0),(0,1),(0,-1),(1,0)]:
            if check(w[0]+x,w[1]+y) and arr[w[0]+x][w[1]+y] !=1 and v[w[0]+x][w[1]+y]==0:
                if (w[0]+x,w[1]+y)==e:
                    return v[w[0]][w[1]]-1
                else:
                    Q.append((w[0]+x,w[1]+y))
                    v[w[0]+x][w[1]+y]=v[w[0]][w[1]]+1
    return 0

T=int(input())
for tc in range(1,T+1):
    N=int(input())
    arr=[list(map(int,input())) for _ in range(N)]
    v=[[0]*N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if arr[i][j]==2:
                s=(i,j)
            if arr[i][j]==3:
                e=(i,j)
    print(f'#{tc} {bfs()}')

```

